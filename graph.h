//
// Created by chris on 03-Mar-18.
//

#ifndef POO_TEMA1_16_GRAPH_H
#define POO_TEMA1_16_GRAPH_H

#include <iostream>
#include "vector.h"
#include <algorithm>

template <typename NodeT>
class NodeList {
    vector <NodeT> nodes;
    int _currNode;

public:
    NodeList() : _currNode(0) {}

    NodeList(const NodeList &other) {
        nodes = other.nodes;
        _currNode = other._currNode;
    }

    ~NodeList() {}

    explicit NodeList(int currNode) {
        _currNode = currNode;
    }

    inline void push_back(NodeT node) {
        nodes.push_back(node);
    }

    inline int getNode() const {
        return _currNode;
    }

    inline int size() const {
        return nodes.size();
    }

    NodeT &operator [](const int& index) const {
        return nodes[index];
    }

    NodeList &operator = (const NodeList &other) {
        nodes = other.nodes;
        _currNode = other._currNode;
    }

    bool operator == (const NodeList &other) const {
        if (nodes.size() == other.size()) {
            bool areEqual = true;
            for (int i = 0; i < nodes.size(); ++i) {
                 areEqual = min(areEqual, nodes[i] == other[i]);
            }

            return areEqual;
        }

        return false;
    }

    bool operator != (const NodeList &other) const {
        return !(*this == other);
    }

    bool operator < (const NodeList &other) const {
        return _currNode < other._currNode;
    }
};

class Edge {
    int _nodeS, _nodeD, _cost;

public:
    Edge() : _nodeS(0), _nodeD(0), _cost(0) {}

    Edge(int nodeS, int nodeD, int cost) {
        _nodeS = nodeS;
        _nodeD = nodeD;
        _cost = cost;
    }

    Edge(const Edge &other) {
        _nodeS = other._nodeS;
        _nodeD = other._nodeD;
        _cost = other._cost;
    }

    ~Edge() {}

    inline int getSource() const {
        return _nodeS;
    }

    inline int getDest() const {
        return _nodeD;
    }

    inline int getCost() const {
        return _cost;
    }

    Edge &operator = (const Edge &other) {
        _nodeS = other._nodeS;
        _nodeD = other._nodeD;
        _cost = other._cost;

        return *this;
    }

    //does not need costs to be equal
    bool operator == (const Edge &other) const {
        return _nodeS == other._nodeS and _nodeD == other._nodeD;
    }

    bool operator != (const Edge &other) const {
        return !(*this == other);
    }

    bool operator < (const Edge &other) const {
        if (_nodeS == other._nodeS) {
            if (_nodeD == other._nodeD) {
                return _cost < other._cost;
            }

            return _nodeD < other._nodeD;
        }
        return _nodeS < other._nodeS;
    }
};

template <typename NodeT>
class Graph {
    int _nodeCnt, _edgeCnt;
    vector <NodeList <NodeT>> G;
    vector <Edge> edges;

    //Information generated by Roy-Floyd
    vector<vector<int>> minDist;
    vector<vector<int>> nextNodeInPath;

    //Information generated by connected components
    vector<vector<int>> compList;
    vector<int> inCC;

    static inline bool byCostCmp(const Edge &a, const Edge &b) {
        return a.getCost() < b.getCost();
    }

    void resize(int newSize) {
        _nodeCnt = newSize;
        G.resize(newSize);
        initializeRoyFloyd();
    }

    void initializeRoyFloyd() {
        //what have i done to deserve this
        minDist.resize(_nodeCnt);
        for (int i = 0; i < _nodeCnt; ++i) {
            minDist[i].resize(_nodeCnt);
        }

        nextNodeInPath.resize(_nodeCnt);
        for (int i = 0; i < _nodeCnt; ++i) {
            nextNodeInPath[i].resize(_nodeCnt);
        }
    }

    void currCC(vector <int> &cc, vector <bool> &used, const int &node) {
        cc.push_back(node);
        used[node] = true;

        for (int nxtInd = 0; nxtInd < G[node].size(); ++nxtInd) {
            int nxtNode = G[node][nxtInd].getIndex();

            if (!used[nxtNode]) {
                currCC(cc, used, nxtNode);
            }
        }
    }

    int findRt(vector <int> &father, const int &node) {
        if (father[node] == node) {
            return node;
        }

        return father[node] = findRt(father, father[node]);
    }

    void mergeDSU(vector <int> &father, vector <int> &depth, int node1, int node2) {
        int root1 = findRt(father, node1);
        int root2 = findRt(father, node2);

        if (depth[root1] < depth[root2]) {
            father[root1] = root2;
        }
        else if (depth[root2] < depth[root1]) {
            father[root2] = root1;
        }
        else {
            father[root2] = root1;
            ++depth[root1];
        }
    }
public:
    Graph() : _nodeCnt(0), _edgeCnt(0) {}

    explicit Graph(int nodeCnt) {
        _nodeCnt = nodeCnt;
        _edgeCnt = 0;
        G.resize(nodeCnt);
        initializeRoyFloyd();
    }

    Graph(const Graph &other) {
        *this = other;
//        _nodeCnt = other._nodeCnt;
//        _edgeCnt = other._edgeCnt;
//        G = other.G;
//        edges = other.edges;
//        minDist = other.minDist;
//        nextNodeInPath = other.nextNodeInPath;
    }

    ~Graph() {}

    friend std::istream &operator >> (std::istream &is, Graph <NodeT> &g) {
        int inputEdgeCnt;
        is >> g._nodeCnt >> inputEdgeCnt;
        g.resize(g._nodeCnt);
        for (int i = 0; i < inputEdgeCnt; ++i) {
            int x, y, cost;
            is >> x >> y >> cost;
            g.addEdge(Edge(x, y, cost));
        }
        return is;
    }

    friend std::ostream &operator << (std::ostream &os, const Graph <NodeT> &g) {
        os << "Graph:\n\n";
        os << g._nodeCnt << ' ' << g._edgeCnt << '\n';
        for (int i = 0; i < g._edgeCnt; ++i) {
            os << g.getEdge(i).getSource() << ' ' << g.getEdge(i).getDest() << ' ' << g.getEdge(i).getCost() << '\n';
        }

        os << "------------------------\n\n";
        return os;
    }

    inline Edge getEdge(const int &index) const {
        return edges[index];
    }

    inline void addEdge(const Edge &edge) {
        ++_edgeCnt;
        edges.push_back(edge);

        int source = edge.getSource();
        int dest = edge.getDest();
        int cost = edge.getCost();

//        if (source < size() or dest < size()) {
//            resize(max(source, dest));
//        }

        G[source].push_back(NodeT(dest, cost));
        G[dest].push_back(NodeT(source, cost));
    }

    inline int size() const {
        return _nodeCnt;
    }

    inline int edgeCnt() const {
        return _edgeCnt;
    }

    //print Roy-Floyd after calculating it
    void printMinDistMatrix(std::ofstream &fout) {
        const int Inf = 0x3f3f3f3f;
        fout << "Roy-Floyd distances:\n\n";
        for (int i = 0; i < _nodeCnt; ++i) {
            for (int j = 0; j < _nodeCnt; ++j) {
                fout << minDist[i][j] << ' ';
            }

            fout << '\n';
        }

        fout << "------------------------\n\n";
    }

    //Roy-Floyd
    void royFloyd() {
        const int Inf = 0x3f3f3f3f;

        //make dp
        vector<vector<vector<int>>> dp;
        dp.resize(_nodeCnt);
        for (int i = 0; i < _nodeCnt; ++i) {
            dp[i].resize(_nodeCnt);
            for (int j = 0; j < _nodeCnt; ++j) {
                dp[i][j].resize(_nodeCnt);
            }
        }

        //initialize dp
        for (int i = 0; i < _nodeCnt; ++i) {
            for (int j = 0; j < _nodeCnt; ++j) {
                if (i == j) {
                    dp[i][j][0] = 0;
                }
                else {
                    dp[i][j][0] = Inf;
                }
            }
        }

        for (int i = 0; i < edges.size(); ++i) {
            Edge currEdge = getEdge(i);
            int source = currEdge.getSource();
            int dest = currEdge.getDest();
            int cost = currEdge.getCost();

            dp[source][dest][0] = min(dp[source][dest][0], cost);
            dp[dest][source][0] = min(dp[dest][source][0], cost);

            nextNodeInPath[source][dest] = dest;
            nextNodeInPath[dest][source] = source;
        }

        //calc dp (nodes added from 0 to k - 1 (+1) ||| 0 means no nodes added)
        for (int k = 1; k <= _nodeCnt; ++k) {
            for (int i = 0; i < _nodeCnt; ++i) {
                for (int j = 0; j < _nodeCnt; ++j) {
                    int kAdded = dp[i][k - 1][k - 1] + dp[k - 1][j][k - 1];
                    int kNotAdded = dp[i][j][k - 1];
                    if (kAdded < kNotAdded) {
                        dp[i][j][k] = kAdded;
                        nextNodeInPath[i][j] = nextNodeInPath[i][k - 1];
                    }
                    else {
                        dp[i][j][k] = kNotAdded;
                    }
                }
            }
        }

        for (int i = 0; i < _nodeCnt; ++i) {
            for (int j = 0; j < _nodeCnt; ++j) {
                if (dp[i][j][_nodeCnt] == Inf) {
                    minDist[i][j] = -1;
                }
                else {
                    minDist[i][j] = dp[i][j][_nodeCnt];
                }
            }
        }
    }

    //intermediary nodes in shortest path between any 2 nodes
    void printShortestPath(std::ofstream &fout, const int &node1, const int &node2) {
        fout << "Shortest path between " << node1 << " and " << node2 << ":\n\n";
        if (minDist[node1][node2] == -1) {
            fout << "DOES NOT EXIST";
            fout << "\n------------------------\n\n";
            return;
        }

        int currNode = node1;
        while (currNode != node2) {
            fout << currNode << ' ';
            currNode = nextNodeInPath[currNode][node2];
        }

        fout << node2 << "\n------------------------\n\n";
    }

    void printConnectedComponents(std::ofstream &fout) {
        fout << "Connected components in current graph:\n\n";
        for (int i = 0; i < compList.size(); ++i) {
            fout << i << ": ";
            for (int j = 0; j < compList[i].size(); ++j) {
                fout << compList[i][j] << ' ';
            }
            fout << '\n';
        }

        fout << "------------------------\n\n";
    }

    //connected components
    void connectedComponents() {
        vector <bool> used(_nodeCnt);
        vector <int> currComp;

        for (int i = 0; i < _nodeCnt; ++i) {
            if (!used[i]) {
                currComp.clear();
                currCC(currComp, used, i);
                compList.push_back(currComp);
            }
        }

        inCC.resize(_nodeCnt);
        for (int i = 0; i < compList.size(); ++i) {
            for (int j = 0; j < compList[i].size(); ++j) {
                int currNode = compList[i][j];
                inCC[currNode] = i;
            }
        }
    }

    //find out if graph is connected
    bool isConnected() {
        return (compList.size() == 1);
    }

    //minimum spanning tree of a connected component
    Graph minSpanningTree(int node) {
        vector <int> father(_nodeCnt);
        vector <int> depth(_nodeCnt);

        for (int i = 0; i < _nodeCnt; ++i) {
            father[i] = i;
            depth[i] = 1;
        }

        int currCC = inCC[node];

        vector <Edge> ccEdges;
        for (int i = 0; i < edges.size(); ++i) {
            Edge currEdge = getEdge(i);
            int source = currEdge.getSource();
            int dest = currEdge.getDest();

            if (inCC[source] == currCC) { //destination cannot be outside CC (the two nodes are connected)
                ccEdges.push_back(currEdge);
            }
        }

        std::sort(ccEdges.begin(), ccEdges.end(), byCostCmp);

//        ccEdges.mergeSort(0, ccEdges.size() - 1, [](Edge a, Edge b) {
//            return a.getCost() < b.getCost();
//        });

        Graph MST(_nodeCnt);

        for (int i = 0; i < ccEdges.size(); ++i) {
            Edge currEdge = ccEdges[i];
            int source = currEdge.getSource();
            int dest = currEdge.getDest();

            if (findRt(father, source) != findRt(father, dest)) {
                mergeDSU(father, depth, source, dest);
                MST.addEdge(currEdge);
            }
        }

        return MST;
    }

    //the intersection of 2 graphs where each edge has the minimum weight of the 2
    Graph operator * (const Graph &other) const {
        Graph g1 = *this;
        Graph g2 = other;

        std::sort(g1.edges.begin(), g1.edges.end());
//        g1.edges.mergeSort(0, g1._edgeCnt - 1, [](Edge a, Edge b) {
//            return a < b;
//        });

        std::sort(g2.edges.begin(), g2.edges.end());
//        g2.edges.mergeSort(0, g2._edgeCnt - 1, [](Edge a, Edge b) {
//            return a < b;
//        });

        Graph ans(max(g1.size(), g2.size()));

        for (int i = 0; i < g1.edgeCnt(); ++i) {
            bool added = false;
            for (int j = 0; j < g2.edgeCnt() and !added; ++j) {
                Edge g1Edge = g1.getEdge(i);
                Edge g2Edge = g2.getEdge(j);
                if (g1Edge == g2Edge and g1Edge.getCost() < g2Edge.getCost()) {
                    added = true;
                    ans.addEdge(g1Edge);
                }
                else if (g1Edge == g2Edge) {
                    added = true;
                    ans.addEdge(g2Edge);
                }
            }

//            if (!added) {
//                ans.addEdge(g1.getEdge(i));
//            }
        }

        return ans;
    }

    NodeList <NodeT> &operator [] (const int &index) const {
        return G[index];
    }

    //TODO add new stuff here
    Graph &operator = (const Graph &other) {
        _nodeCnt = other._nodeCnt;
        _edgeCnt = other._edgeCnt;
        G = other.G;
        edges = other.edges;
        minDist = other.minDist;
        nextNodeInPath = other.nextNodeInPath;
        compList = other.compList;
        inCC = other.inCC;
        return *this;
    }

    bool operator == (const Graph &other) const {
        vector <Edge> v = edges;
        std::sort(v.begin(), v.end());
//        v.mergeSort(0, v.size() - 1, [](Edge a, Edge b) {
//            return a < b;
//        });

        bool areEqual = true;
        for (int i = 0; i < v.size() and areEqual; ++i) {
            areEqual = min(areEqual, v[i] == other.getEdge(i));
        }

        return areEqual;
    }

    bool operator != (const Graph &other) const {
        return !(*this == other);
    }

    bool operator < (const Graph &other) const {
        return size() < other.size();
    }
};

#endif //POO_TEMA1_16_GRAPH_H
